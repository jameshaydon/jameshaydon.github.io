<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- google fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

    
      
      <meta name="description" content="Clarification on my comments about programming style, bugs and the UK ATC meltdown." />
      
    

      <title>James Haydon - On programming style and bugs -- UK ATC meltdown </title>

      
        <link rel="alternate" type="application/atom+xml" title="RSS" href="https://jameshaydon.github.io/atom.xml">
      

      
          <link rel="stylesheet" href="https://jameshaydon.github.io/site.css">
      

      
      

          <!-- Google tag (gtag.js) -->
          <script async src="https://www.googletagmanager.com/gtag/js?id=G-X4MP59NZ35"></script>
          <script>
           window.dataLayer = window.dataLayer || [];
           function gtag(){dataLayer.push(arguments);}
           gtag('js', new Date());

           gtag('config', 'G-X4MP59NZ35');
          </script>
  </head>

    <body class="hack dark main container">
        
    
        
                
                    <header>
                        <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
                        
                            <a itemprop="url"
                               class=""
                               href="https://jameshaydon.github.io">
                                <span itemprop="name">Home</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://github.com/jameshaydon">
                                <span itemprop="name">GitHub</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://jameshaydon.github.io/papers">
                                <span itemprop="name">Papers</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://github.com/jameshaydon/lawvere">
                                <span itemprop="name">lawvere-lang</span></a>
                        
                        </nav>
                    </header>
                
            
    

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">On programming style and bugs -- UK ATC meltdown</h1>
        <span class="muted">
    <svg class="icon i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>9 minute read</span>
    <svg class="icon i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2023-09-15
</span>
    </header>
    <div itemprop="articleBody">
      <p>This is part 3 of my blog posts about the UK air traffic control meltdown. You might want to read <a href="/nats-fail">part one</a> and <a href="/what-went-wrong">part two</a>.</p>
<p>Having had some time to process some of the comments about my first post, I
realise now that I was not clear in communicating my thoughts about the
programming style, and how that contributed to the existence of the bug. I will
have another go now. The point I was trying to make was:</p>
<p>With a better programming style, the bug might not have been made <strong>even if the
code is only meant for flight plans with no duplicate waypoints</strong>.<span id="continue-reading"></span>
Of course I also agree that better spec/requirements would have helped too, as
would have <a href="/what-went-wrong">many things</a>.</p>
<p>I've read replies to my previous blog posts with comments of the sort:</p>
<ul>
<li>Why the &quot;out of the blue&quot; comment about &quot;imperative&quot; programming in the middle
of the post?</li>
<li>What is even meant by &quot;imperative&quot; programming? How is it relevant to the rest
of the post?</li>
<li>Why blame the bug on programming style, when it is just that the original code
was not aware of the possibility of waypoints with duplicate names? The
original algorithm (probably) works fine on those flight plans.</li>
</ul>
<p>What I hope to convince you of in this post is that the programming style <em>does</em>
matter, the bug might not have occurred when using a specific coding style, even
if the programmer was not aware of the duplicate waypoint issue.</p>
<h2 id="what-did-i-mean-by-imperative">What did I mean by &quot;imperative&quot;?</h2>
<p>Using this word was a mistake. What I should have said instead was roughly:
<em>&quot;not correct by construction&quot;</em><sup class="footnote-reference"><a href="#1">1</a></sup>. What I did was conflate
&quot;correct-by-construction&quot; with my own personal preference in achieving this
programming style, which is using functional programming.</p>
<p>There is no precise definition of what &quot;correct-by-construction&quot; means, but it
would at least include:</p>
<ul>
<li>representing domain objects with data structures,</li>
<li>only operating on them with functions that are known to preserve certain
invariants, so that they are &quot;safe&quot;,</li>
<li>building up a solution by composing such functions.</li>
</ul>
<p>The idea is that if the &quot;base&quot; functions are &quot;correct&quot; (in some way), then by
induction the full program is too.</p>
<p>In correct-by-construction programming the invariants are expressed in terms of
the domain: the &quot;modelling gap&quot; is small. Programs that are not
correct-by-construction have invariants expressed in terms of the
implementation. The former are easier to state and to reason about. The latter
are harder to come up with and more error prone. The smaller modelling gap also
ensures that errors, should they occur, are usually &quot;closer&quot;<sup class="footnote-reference"><a href="#2">2</a></sup> to the route
cause, and this can make failure modes less intense.</p>
<h2 id="another-look-at-the-problem">Another look at the problem</h2>
<p>Let us from now on assume that <strong><em>we do not know that a flight plan can contain
duplicate waypoints</em></strong>, and that we <strong><em>assume they are unique</em></strong>, and look at
the problem anew.</p>
<p>We are given two versions of the flight plan, ICAO and ADEXP, each containing
information the other does not have. Our goal is to extract the UK part of the
ICAO flight plan, using data from the ADEXP plan.</p>
<p>One possibility, which sounds like what the original code did, is to keep the
data as it is, and perform various operations in a <code>while</code> loop which mutate
some variables like <code>current_endpoint_candidate</code> until we are satisfied we have
found two indexes <code>start_idx</code> and <code>end_idx</code> which delimit the UK portion of the
flight plan. This is not correct by construction: the end result is an <code>end_idx</code>
which for which <code>end_idx &lt; start_idx</code>, it doesn't correspond to a
sub-flight-plan at all. The code has &quot;gone wrong&quot;, and not noticed: the
invariant that the pair of indices represent a valid sub-plan has been violated.
Noticing that something has gone wrong is important: the closer you are to the
root cause, the more likely the exception will contain the information that is
relevant to those who are dealing with the crash. It may even have failed
gracefully at this point.</p>
<p>The correct-by-construction approach, at least the one that I chose, is to
operate on a version of the flight plan that combines all the information you
need. This therefore involves a first step which works out how the ICAO and
ADEXP plans &quot;match up&quot;.</p>
<p>In the original post, I wrote a function <code>reconcile :: ICAO p r -&gt; [p] -&gt; [Combined p r]</code>, to this effect. Now, suppose that I hadn't realised waypoint
names were non-unique, then I would have reasoned that the plans can only match
up in one way (or none), since every waypoint in the ICAO plan can only match a
single point in the ADEXP list. So I'd have written, instead:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">reconcile&#39; </span><span style="color:#b48ead;">::</span><span> (</span><span style="color:#b48ead;">Eq </span><span style="color:#bf616a;">p</span><span>) </span><span style="color:#b48ead;">=&gt; ICAO </span><span style="color:#bf616a;">p r </span><span style="color:#b48ead;">-&gt;</span><span> [</span><span style="color:#bf616a;">p</span><span>] </span><span style="color:#b48ead;">-&gt; Maybe</span><span> (</span><span style="color:#b48ead;">Combined </span><span style="color:#bf616a;">p r</span><span>)
</span><span>reconcile&#39; (</span><span style="color:#d08770;">End</span><span> p) [p&#39;] | p == p&#39; = pure (</span><span style="color:#d08770;">End</span><span> p)
</span><span>reconcile&#39; (</span><span style="color:#d08770;">Leg</span><span> p r rest) (p&#39; : ps) | p == p&#39; = </span><span style="color:#b48ead;">do
</span><span>  </span><span style="color:#b48ead;">let</span><span> (skipped, restAdexp) = span (\x -&gt; x /= start rest) ps
</span><span>  recoRest &lt;- reconcile&#39; rest restAdexp
</span><span>  pure (</span><span style="color:#d08770;">Leg</span><span> p </span><span style="color:#d08770;">Via</span><span> {route = r, through = skipped} recoRest)
</span><span>reconcile&#39; _ _ = </span><span style="color:#d08770;">Nothing
</span></code></pre>
<p>This function is simpler than <code>reconcile</code> from the original post and does the
obvious thing: when reconciling a leg of the ICAO plan with the ADEXP list, it
will skip all the ADEXP points that are not equal to the next point in the ICAO
plan, and then reconciles the rest of the plan recursively.</p>
<p>This function is <em>wrong</em>, because it doesn't consider the possibility of
duplicate waypoints, but it's not nearly as wrong as the function in NATS's
system, because of the correct-by-construction programming style. It will either:</p>
<ul>
<li>return <code>Nothing</code> because it can't create a valid domain object (a flight plan),
in which case it <em>knows</em> is should now fail gracefully, or,</li>
<li>succeed correctly, or,</li>
<li>succeed incorrectly: but this is now made much more unlikely (see below) and
far more understandable: the input data was ambiguous.</li>
</ul>
<p>The code for extracting the UK part of the plan is the same as in the original
post, this is quite simple once we have the version flight plan which combines
all the information we need. All that changes is pattern matching on <code>Maybe</code>
value instead of a list:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#8fa1b3;">ukPartOfICAO&#39; </span><span style="color:#b48ead;">::</span><span> (</span><span style="color:#b48ead;">Eq </span><span style="color:#bf616a;">p</span><span>) </span><span style="color:#b48ead;">=&gt;</span><span> (</span><span style="color:#bf616a;">p </span><span style="color:#b48ead;">-&gt; Bool</span><span>) </span><span style="color:#b48ead;">-&gt; ICAO </span><span style="color:#bf616a;">p r </span><span style="color:#b48ead;">-&gt;</span><span> [</span><span style="color:#bf616a;">p</span><span>] </span><span style="color:#b48ead;">-&gt; Either Err</span><span> (</span><span style="color:#b48ead;">ICAO </span><span style="color:#bf616a;">p r</span><span>)
</span><span>ukPartOfICAO&#39; uk icao adexp = </span><span style="color:#b48ead;">case</span><span> reconcile&#39; icao adexp </span><span style="color:#b48ead;">of
</span><span>  </span><span style="color:#d08770;">Just</span><span> plan -&gt; projectICAO &lt;$&gt; ukSegment uk plan
</span><span>  _ -&gt; </span><span style="color:#d08770;">Left CannotReconcileIcaoAdexp
</span></code></pre>
<p>On the original example, and the flight plan that caused the air traffic control
incident, this version simply <em>works</em>:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>λ&gt; ukPortionOfICAO&#39; inUK icao adexp
</span><span style="color:#d08770;">Right</span><span> (</span><span style="color:#d08770;">Leg </span><span>&quot;</span><span style="color:#a3be8c;">T</span><span>&quot; </span><span style="color:#d08770;">8</span><span> (</span><span style="color:#d08770;">Leg </span><span>&quot;</span><span style="color:#a3be8c;">O</span><span>&quot; </span><span style="color:#d08770;">5</span><span> (</span><span style="color:#d08770;">Leg </span><span>&quot;</span><span style="color:#a3be8c;">P</span><span>&quot; </span><span style="color:#d08770;">1</span><span> (</span><span style="color:#d08770;">End </span><span>&quot;</span><span style="color:#a3be8c;">Y</span><span>&quot;))))
</span></code></pre>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>                                 UK portion of ICAO
</span><span>                       ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
</span><span>           4       2        8         5              1           9
</span><span>ICAO:  F------Q--------T--------O-----------P---------------Y--------U
</span><span>
</span><span>ADEXP: F   S  Q    C   T   A    O  E  X     P   W   B   Q   Y        U
</span><span>                       UK  UK   UK UK UK    UK  UK
</span></code></pre>
<p>The bug would therefore have been completely avoided, even if the failure modes
were bad, and even though the spec might not have made the duplicate waypoint
issue clear. The reason it still works is that the reconciliation still exists,
and the duplicate waypoint doesn't get in the way of finding it.</p>
<p>The reconciliation is also unique in this case, so the processing of the flight
plan is completely correct. The code here differs from the code of the previous
post only when there are multiple reconciliations: the first post has code which
fails with a an error, whereas this code will take the first reconciliation
(which might be the wrong one). This would only happen if there are duplicate
waypoints in in the ADEXP list, say <code>w1</code> and <code>w2</code>, appearing in that order.
Since <code>reconcile'</code> settles on on the first matching waypoint it finds, to have
gone wrong it would match <code>w</code> in the ICAO list with <code>w1</code> when it should have
matched it with <code>w2</code>. This would mean that there is a leg of the ICAO flight
plan which skips over <code>w1</code> and ends at <code>w2</code>. Since waypoints with duplicate
names are supposed to be very far apart, and flight plan legs are <em>not</em> supposed
to be over very long distances, this shouldn't happen. Indeed this requirement
is in place precisely to avoid flight plans being ambiguous.</p>
<p>The code of the original blog post was proceeding with an &quot;abundance of caution&quot;
so to speak.</p>
<p>Full code <a href="https://github.com/jameshaydon/uk-portion-of-ICAO" title="GitHub">here</a>.</p>
<p><strong>To summarise:</strong><br/> This coding style represents the objects of the domain
with data structures. It operates on those structures with semantically
meaningful operations, e.g. &quot;removing the first leg of a flight plan results in
a flight plan&quot;. So in the end you get a valid flight plan, not indexes into a
list which don't mean anything.</p>
<p><em>In my opinion</em>, it is important that we slowly move to such a coding style. I
would hope to see this style used more and more in industry, especially in
critical software.</p>
<p>Notes:</p>
<ul>
<li>It's possible to code in this style in most languages.</li>
<li>It's possible to code in non-correct-by-construction style in <em>all</em> languages.</li>
<li>But <strong><em>in my opinion</em></strong>, some languages lend themselves more to this style
than others, for example those that are functional.</li>
<li>Correct-by-construction style most certainly doesn't prevent <em>all</em> bugs, just
some of them.</li>
<li>There are many other techniques/tools to prevent bugs.</li>
<li>Static types is <em>not</em> a prerequisite to correct-by-construction style. I've
seen these ideas espoused by the <a href="https://clojure.org/">Clojure</a>
community, for example.</li>
<li>Languages with <a href="https://en.wikipedia.org/wiki/Dependent_type">dependent types</a>
or <a href="https://ucsd-progsys.github.io/liquidhaskell/">SMT plugins</a> allow
invariants to be machine verified.</li>
</ul>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>&quot;Correct-by-construction&quot; usually refers to something more precise that what I am talking about here. Most people would use this term when the criteria for &quot;correct&quot; are clearly stated, and the correctness is formally verified. I couldn't think of any other term to describe this coding style though.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Closer conceptually, and in terms of the call-graph.</p>
</div>

    </div>

    
        <footer>
            <hr>
            <p>
                
                    Published by James Haydon
                
                
                
            </p>
            
            
        </footer>
    
</article>


    </body>

</html>
